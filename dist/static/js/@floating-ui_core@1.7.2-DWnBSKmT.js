import{g as e,a as t,b as n,e as a,c as i,d as l,f as o,h as s,i as r,j as c,k as f,l as m,m as g,r as y,n as u}from"./@floating-ui_utils@0.2.10-QZXVpxRV.js";function d(a,i,o){let{reference:s,floating:r}=a;const c=n(i),f=l(i),g=m(f),y=e(i),u="y"===c,d=s.x+s.width/2-r.width/2,p=s.y+s.height/2-r.height/2,x=s[g]/2-r[g]/2;let w;switch(y){case"top":w={x:d,y:s.y-r.height};break;case"bottom":w={x:d,y:s.y+s.height};break;case"right":w={x:s.x+s.width,y:p};break;case"left":w={x:s.x-r.width,y:p};break;default:w={x:s.x,y:s.y}}switch(t(i)){case"start":w[f]-=x*(o&&u?-1:1);break;case"end":w[f]+=x*(o&&u?-1:1)}return w}const p=async(e,t,n)=>{const{placement:a="bottom",strategy:i="absolute",middleware:l=[],platform:o}=n,s=l.filter(Boolean),r=await(null==o.isRTL?void 0:o.isRTL(t));let c=await o.getElementRects({reference:e,floating:t,strategy:i}),{x:f,y:m}=d(c,a,r),g=a,y={},u=0;for(let p=0;p<s.length;p++){const{name:n,fn:l}=s[p],{x:x,y:w,data:v,reset:h}=await l({x:f,y:m,initialPlacement:a,placement:g,strategy:i,middlewareData:y,rects:c,platform:o,elements:{reference:e,floating:t}});f=null!=x?x:f,m=null!=w?w:m,y={...y,[n]:{...y[n],...v}},h&&u<=50&&(u++,"object"==typeof h&&(h.placement&&(g=h.placement),h.rects&&(c=!0===h.rects?await o.getElementRects({reference:e,floating:t,strategy:i}):h.rects),({x:f,y:m}=d(c,g,r))),p=-1)}return{x:f,y:m,placement:g,strategy:i,middlewareData:y}};async function x(e,t){var n;void 0===t&&(t={});const{x:l,y:o,platform:s,rects:r,elements:c,strategy:f}=e,{boundary:m="clippingAncestors",rootBoundary:g="viewport",elementContext:u="floating",altBoundary:d=!1,padding:p=0}=a(t,e),x=i(p),w=c[d?"floating"===u?"reference":"floating":u],v=y(await s.getClippingRect({element:null==(n=await(null==s.isElement?void 0:s.isElement(w)))||n?w:w.contextElement||await(null==s.getDocumentElement?void 0:s.getDocumentElement(c.floating)),boundary:m,rootBoundary:g,strategy:f})),h="floating"===u?{x:l,y:o,width:r.floating.width,height:r.floating.height}:r.reference,b=await(null==s.getOffsetParent?void 0:s.getOffsetParent(c.floating)),A=await(null==s.isElement?void 0:s.isElement(b))&&await(null==s.getScale?void 0:s.getScale(b))||{x:1,y:1},R=y(s.convertOffsetParentRelativeRectToViewportRelativeRect?await s.convertOffsetParentRelativeRectToViewportRelativeRect({elements:c,rect:h,offsetParent:b,strategy:f}):h);return{top:(v.top-R.top+x.top)/A.y,bottom:(R.bottom-v.bottom+x.bottom)/A.y,left:(v.left-R.left+x.left)/A.x,right:(R.right-v.right+x.right)/A.x}}const w=e=>({name:"arrow",options:e,async fn(n){const{x:s,y:r,placement:c,rects:f,platform:y,elements:u,middlewareData:d}=n,{element:p,padding:x=0}=a(e,n)||{};if(null==p)return{};const w=i(x),v={x:s,y:r},h=l(c),b=m(h),A=await y.getDimensions(p),R="y"===h,E=R?"top":"left",P=R?"bottom":"right",k=R?"clientHeight":"clientWidth",O=f.reference[b]+f.reference[h]-v[h]-f.floating[b],D=v[h]-f.reference[h],T=await(null==y.getOffsetParent?void 0:y.getOffsetParent(p));let L=T?T[k]:0;L&&await(null==y.isElement?void 0:y.isElement(T))||(L=u.floating[k]||f.floating[b]);const S=O/2-D/2,B=L/2-A[b]/2-1,j=g(w[E],B),C=g(w[P],B),F=j,V=L-A[b]-C,H=L/2-A[b]/2+S,W=o(F,H,V),_=!d.arrow&&null!=t(c)&&H!==W&&f.reference[b]/2-(H<F?j:C)-A[b]/2<0,q=_?H<F?H-F:H-V:0;return{[h]:v[h]+q,data:{[h]:W,centerOffset:H-W-q,..._&&{alignmentOffset:q}},reset:_}}}),v=function(t){return void 0===t&&(t={}),{name:"flip",options:t,async fn(i){var l,o;const{placement:m,middlewareData:g,rects:y,initialPlacement:u,platform:d,elements:p}=i,{mainAxis:w=!0,crossAxis:v=!0,fallbackPlacements:h,fallbackStrategy:b="bestFit",fallbackAxisSideDirection:A="none",flipAlignment:R=!0,...E}=a(t,i);if(null!=(l=g.arrow)&&l.alignmentOffset)return{};const P=e(m),k=n(u),O=e(u)===u,D=await(null==d.isRTL?void 0:d.isRTL(p.floating)),T=h||(O||!R?[s(u)]:r(u)),L="none"!==A;!h&&L&&T.push(...c(u,R,A,D));const S=[u,...T],B=await x(i,E),j=[];let C=(null==(o=g.flip)?void 0:o.overflows)||[];if(w&&j.push(B[P]),v){const e=f(m,y,D);j.push(B[e[0]],B[e[1]])}if(C=[...C,{placement:m,overflows:j}],!j.every(e=>e<=0)){var F,V;const e=((null==(F=g.flip)?void 0:F.index)||0)+1,t=S[e];if(t){if(!("alignment"===v&&k!==n(t))||C.every(e=>e.overflows[0]>0&&n(e.placement)===k))return{data:{index:e,overflows:C},reset:{placement:t}}}let a=null==(V=C.filter(e=>e.overflows[0]<=0).sort((e,t)=>e.overflows[1]-t.overflows[1])[0])?void 0:V.placement;if(!a)switch(b){case"bestFit":{var H;const e=null==(H=C.filter(e=>{if(L){const t=n(e.placement);return t===k||"y"===t}return!0}).map(e=>[e.placement,e.overflows.filter(e=>e>0).reduce((e,t)=>e+t,0)]).sort((e,t)=>e[1]-t[1])[0])?void 0:H[0];e&&(a=e);break}case"initialPlacement":a=u}if(m!==a)return{reset:{placement:a}}}return{}}}},h=new Set(["left","top"]);const b=function(i){return void 0===i&&(i=0),{name:"offset",options:i,async fn(l){var o,s;const{x:r,y:c,placement:f,middlewareData:m}=l,g=await async function(i,l){const{placement:o,platform:s,elements:r}=i,c=await(null==s.isRTL?void 0:s.isRTL(r.floating)),f=e(o),m=t(o),g="y"===n(o),y=h.has(f)?-1:1,u=c&&g?-1:1,d=a(l,i);let{mainAxis:p,crossAxis:x,alignmentAxis:w}="number"==typeof d?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:d.mainAxis||0,crossAxis:d.crossAxis||0,alignmentAxis:d.alignmentAxis};return m&&"number"==typeof w&&(x="end"===m?-1*w:w),g?{x:x*u,y:p*y}:{x:p*y,y:x*u}}(l,i);return f===(null==(o=m.offset)?void 0:o.placement)&&null!=(s=m.arrow)&&s.alignmentOffset?{}:{x:r+g.x,y:c+g.y,data:{...g,placement:f}}}}},A=function(t){return void 0===t&&(t={}),{name:"shift",options:t,async fn(i){const{x:l,y:s,placement:r}=i,{mainAxis:c=!0,crossAxis:f=!1,limiter:m={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...g}=a(t,i),y={x:l,y:s},d=await x(i,g),p=n(e(r)),w=u(p);let v=y[w],h=y[p];if(c){const e="y"===w?"bottom":"right",t=v+d["y"===w?"top":"left"],n=v-d[e];v=o(t,v,n)}if(f){const e="y"===p?"bottom":"right",t=h+d["y"===p?"top":"left"],n=h-d[e];h=o(t,h,n)}const b=m.fn({...i,[w]:v,[p]:h});return{...b,data:{x:b.x-l,y:b.y-s,enabled:{[w]:c,[p]:f}}}}}};export{w as a,p as c,x as d,v as f,b as o,A as s};
